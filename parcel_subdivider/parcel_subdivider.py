# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ParcelDivider
                                 A QGIS plugin
 This plugin automates land subdivision
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-18
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Denis Kimaru
        email                : ropdeno@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os.path

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog

from qgis.utils import iface
from qgis.core import QgsGeometry, QgsField, QgsVectorLayer, QgsFeatureRequest, QgsFeature, QgsPointXY, QgsProject, \
    QgsSpatialIndex, QgsRectangle, QgsPoint
import os
from math import *

# from qgis.gui import QgsMapCanvas

# Initialize Qt resources from file resources.py
# Import the code for the dialog
from .parcel_subdivider_dialog import ParcelDividerDialog


def get_layer_names_and_objects():
    layer_name_list = []
    layer_object_list = []
    iface.mapCanvas().refresh()
    layers_objects = iface.mapCanvas().layers()
    for layer_object in layers_objects:
        layer_name = layer_object.name()
        layer_object_list.append(layer_object)
        layer_name_list.append(layer_name)
    return layer_name_list, layer_object_list


# ================================= Instructions ============================
# =  1. All road attributes should either be called road, roads, rd or rds  =
# =	 2. Names of parcels should at all times be called names				=
# =																			=
# =																			=
# =																			=
# =																			=
# =																			=
# =																			=
# ============================================================================

def get_selected_layer_object():
    selected_layer_object = ""
    iface.mapCanvas().refresh()
    layers_objects = iface.mapCanvas().layers()
    for layer_object in layers_objects:
        layer_name = layer_object.name()
        if layer_name == checked_layer:
            selected_layer_object = layer_object

    return selected_layer_object


def length_of_line(list_of_vertices):
    count = 0
    total_line_length = 0
    while count < len(list_of_vertices) - 1:
        point_1 = list_of_vertices[count]
        point_2 = list_of_vertices[count + 1]
        point_1_x = point_1.x()
        point_1_y = point_1.y()
        point_2_x = point_2.x()
        point_2_y = point_2.y()
        change_in_x = abs(point_2_x - point_1_x)
        change_in_y = abs(point_2_y - point_1_y)
        line_length = sqrt(change_in_x ** 2 + change_in_y ** 2)
        total_line_length += line_length
        count += 1
    return total_line_length


def line_bearing(point_1, point_2):
    bearing = 0
    change_in_x = point_2.x() - point_1.x()
    change_in_y = point_2.y() - point_1.y()
    try:
        angle_change = degrees(atan(change_in_x / change_in_y))
    except ZeroDivisionError:
        angle_change = 90
    if change_in_x >= 0 < change_in_y:
        bearing = angle_change
    elif change_in_x > 0 >= change_in_y or change_in_x < 0 >= change_in_y:
        bearing = 180 + angle_change
    elif change_in_x < 0 < change_in_y:
        bearing = 360 + angle_change

    return bearing


def convert_from_point_to_pointxy(points_list):
    p_xy_list = []
    for pnt in points_list:
        x_coordinate = pnt.x()
        y_coordinate = pnt.y()
        pointxy = QgsPointXY(x_coordinate, y_coordinate)
        p_xy_list.append(pointxy)
    return p_xy_list


def remove_duplicates_in_list(lst):
    new_lst = []
    for value in lst:
        if value not in new_lst:
            new_lst.append(value)
    return new_lst


def rearrange_list(lst, initial_index, last_index):
    new_lst = []
    initial_list_point = initial_index
    length_of_lst = len(lst)
    if initial_index > last_index:
        final_list_point = last_index
    else:
        final_list_point = last_index + 1
    index_difference = final_list_point - initial_list_point

    if initial_list_point < 0:
        initial_list_point = initial_list_point + length_of_lst
        final_list_point = initial_list_point - 1

    if index_difference < 0:
        initial_list_point -= length_of_lst
        count = initial_list_point
        while count <= final_list_point:
            new_lst.append(lst[count])
            count += 1
    elif index_difference >= 0:
        del new_lst
        new_lst = lst[initial_list_point:final_list_point]
    if final_list_point > len(lst):
        new_lst.append(lst[0])

    return new_lst


def reverse_rearrange_list(lst, init_pnt, last_pnt):
    count = init_pnt
    new_lst = []
    while count >= last_pnt:
        pnt = lst[count]
        new_lst.append(pnt)

        count -= 1

    return new_lst


def get_gradient_y_intercept(vertex_one, vertex_two):
    x1_coordinate = vertex_one.x()
    x2_coordinate = vertex_two.x()
    y1_coordinate = vertex_one.y()
    y2_coordinate = vertex_two.y()
    gradient = None
    y_intercept = x1_coordinate
    if x2_coordinate - x1_coordinate != 0:
        gradient = (y2_coordinate - y1_coordinate) / (x2_coordinate - x1_coordinate)
        y_intercept = (gradient * (-x2_coordinate)) + y2_coordinate

    return gradient, y_intercept


def feature_shared_vertices(feat_1_geometry, feat_2_geometry):
    feat_1_vertices = [vertex for vertex in feat_1_geometry.vertices()]
    feat_2_vertices = [vertex for vertex in feat_2_geometry.vertices()]

    shared_vertices = []
    for feature_2_vertex in feat_1_vertices:
        if feature_2_vertex in feat_2_vertices:
            shared_vertices.append(feature_2_vertex)
    return shared_vertices


def feature_has_road(feature_geom, road_geom):
    shared_vertices = feature_shared_vertices(feature_geom, road_geom)
    if len(shared_vertices) > 1:
        return True
    else:
        return False


def point_in_line(line_points, a_point):
    x1_coordinate = line_points[0].x()
    x2_coordinate = line_points[1].x()
    y1_coordinate = line_points[0].y()
    y2_coordinate = line_points[1].y()
    x_coordinate = a_point.x()
    y_coordinate = round(a_point.y(), 6)
    calculated_y_coordinate = None

    if y2_coordinate - y1_coordinate != 0 and x2_coordinate - x1_coordinate != 0:
        gradient = (y2_coordinate - y1_coordinate) / (x2_coordinate - x1_coordinate)
        y_intercept = (gradient * (-x2_coordinate)) + y2_coordinate
        calculated_y_coordinate = round(gradient * x_coordinate + y_intercept, 5)
    elif y2_coordinate - y1_coordinate == 0:
        calculated_y_coordinate = y2_coordinate
    if x2_coordinate - x1_coordinate == 0 and x2_coordinate == x_coordinate or calculated_y_coordinate == y_coordinate:
        small_change_in_x = abs(x2_coordinate - x1_coordinate)
        x_change = abs(x2_coordinate - x_coordinate)
        return True

    else:
        return False


def distance_in_chain_of_vertices(lst):
    loop_count = 0
    max_loop_count = len(lst) - 2
    total_length = 0
    while loop_count <= max_loop_count:
        p1_x = lst[loop_count].x()
        p1_y = lst[loop_count].y()
        p2_x = lst[loop_count + 1].x()
        p2_y = lst[loop_count + 1].y()
        change_in_x = p2_x - p1_x
        change_in_y = p2_y - p1_y
        length = sqrt(change_in_x ** 2 + change_in_y ** 2)
        total_length += length

        loop_count += 1

    return total_length


width_of_road = 9
checked_layer = "land_with_roads"
corner_coordinate = (10, 15)
corner_inclination = "negative"
corner_location = "top"
selected_layer = get_selected_layer_object()
point_coordinate = (111268.81385924691858236, 109776.93211387348128483)  #
point = QgsPoint(point_coordinate[0], point_coordinate[1])


def check_road_direction(sel_vertex, sel_feat_vert, rd_feature_vertex_list):
    anticlockwise_dir = "clockwise"
    clockwise_dir = "anticlockwise"
    direction_lst = []
    distance_lst = []
    feature_vertex_list = []
    for rd_feature_vertex in rd_feature_vertex_list:
        road_feat_index = sel_feat_vert.index(rd_feature_vertex)
        point_feat_index = sel_feat_vert.index(sel_vertex)
        forward_coordinated = rearrange_list(sel_feat_vert, point_feat_index, road_feat_index)
        forward_distance = distance_in_chain_of_vertices(forward_coordinated)
        distance_lst.append(forward_distance)
        direction_lst.append(clockwise_dir)
        new_feat_vert = remove_duplicates_in_list(sel_feat_vert)
        new_feat_vert.reverse()
        road_feat_index = new_feat_vert.index(rd_feature_vertex)
        point_feat_index = new_feat_vert.index(sel_vertex)
        reversed_coordinates = rearrange_list(new_feat_vert, point_feat_index, road_feat_index)
        reverse_distance = distance_in_chain_of_vertices(reversed_coordinates)
        distance_lst.append(reverse_distance)
        direction_lst.append(anticlockwise_dir)
        feature_vertex_list.append(rd_feature_vertex)
        feature_vertex_list.append(rd_feature_vertex)

    shortest_dist = min(distance_lst)
    shortest_distance_index = distance_lst.index(shortest_dist)
    closest_vertex = feature_vertex_list[shortest_distance_index]
    road_dir = direction_lst[shortest_distance_index]

    return road_dir, closest_vertex


def final_road_vertex(shared_vertex, selected_feature_object):
    # if self.road_creator_constructor.clockwise_road_direction:
    selected_feat_geometry = selected_feature_object.geometry()
    selected_feat_vertices = [vertex for vertex in selected_feat_geometry.vertices()]
    counter = 0
    final_line_points = None
    while counter < len(selected_feat_vertices) - 1:
        vertex_1 = selected_feat_vertices[counter]
        vertex_2 = selected_feat_vertices[counter + 1]
        line_points = [vertex_1, vertex_2]
        in_line = point_in_line(line_points, shared_vertex)
        if in_line:
            final_line_points = line_points
            break
        counter += 1

    # road_direction = check_road_direction(True)
    # if road_direction == "clockwise":
    #     pass
    # elif road_direction == "anticlockwise":
    final_line_points.reverse()
    final_line_point = final_line_points[1]

    return final_line_point, selected_feat_vertices


def select_vertex(vertices):
    y_coordinates = []
    for vertex in vertices:
        y_coordinates.append(vertex.y())
    min_y_coordinate = min(y_coordinates)
    min_y_coordinate_index = y_coordinates.index(min_y_coordinate)
    final_vertex = vertices[min_y_coordinate_index]
    return final_vertex


class RoadNetworkCreator:

    def __init__(self, road_width):
        self.road_width = road_width
        self.initial_points = False
        self.final_point = True
        self.adjacent_to_existing_road = True
        self.corner = True
        self.clockwise_road_direction = True
        self.vertices_to_remove = []
        self.nearest_road_vertex = None

    def parallel_line_coordinate_change(self, angle_1, angle_2=None):  # This returns coordinates of vertices
        # that should create a parallel line. The parallel line forms a road.
        # print(angle_1, angle_2)
        change_in_x = 0
        change_in_y = 0
        bearing_difference = 0
        if angle_2 is not None:
            bearing_difference = angle_2 - angle_1
        if self.initial_points:
            if self.corner:
                if self.clockwise_road_direction:  # this checks if the road will move in a clockwise direction
                    angle_betta = angle_1 + 45
                else:
                    angle_betta = angle_1 - 45
                road_diagonal = sqrt(self.road_width ** 2 + self.road_width ** 2)
                change_in_x = road_diagonal * sin(radians(angle_betta))
                change_in_y = road_diagonal * cos(radians(angle_betta))
                # change in coordinate value is from the newly created coordinates of corner adjacent to road
                self.initial_points = True
                self.corner = False
            elif self.adjacent_to_existing_road:  # Checks id a parcel has a feeder road. Normally, all parcels should
                # have access roads
                change_in_x = self.road_width * sin(radians(angle_1))
                change_in_y = self.road_width * cos(radians(angle_1))
                # change in coordinate value is from the closest road point
                self.adjacent_to_existing_road = False
                self.initial_points = False
        elif self.final_point:
            angle_alpha = angle_1
            if self.clockwise_road_direction:
                angle_theta = 360 - bearing_difference
            else:
                angle_theta = bearing_difference
            change_in_x = (self.road_width * sin(radians(angle_alpha))) / sin(radians(angle_theta))
            change_in_y = (self.road_width * cos(radians(angle_alpha))) / sin(radians(angle_theta))
            # change in coordinate value is from where the parcel is divided
            self.final_point = False
        else:
            # change_in_x = (self.road_width * sin(radians(angle_2 - angle_1))) / sin(radians(angle_2))
            # change_in_y = (self.road_width * cos(radians(angle_2 - angle_1))) / sin(radians(angle_2))
            if bearing_difference < 0:
                bearing_difference = abs(bearing_difference)
            elif bearing_difference > 360:
                bearing_difference = 360 - bearing_difference
            angle_betta = 0.5 * (360 - bearing_difference)
            if self.clockwise_road_direction:
                if angle_2 < angle_1:
                    angle_betta = 0.5 * bearing_difference
                new_point_bearing = angle_2 + angle_betta
                # if angle_2 < angle_1:
                change_in_x = (self.road_width * sin(radians(new_point_bearing))) / sin(radians(angle_betta))
                change_in_y = (self.road_width * cos(radians(new_point_bearing))) / sin(radians(angle_betta))
                # else:
                #     change_in_x = (self.road_width * cos(radians(new_point_bearing))) / sin(radians(angle_betta))
                #     change_in_y = (self.road_width * sin(radians(new_point_bearing))) / sin(radians(angle_betta))
            else:
                if angle_2 > angle_1:
                    angle_betta = 0.5 * bearing_difference
                new_point_bearing = angle_2 - angle_betta
                change_in_x = (self.road_width * sin(radians(new_point_bearing))) / sin(radians(angle_betta))
                change_in_y = (self.road_width * cos(radians(new_point_bearing))) / sin(radians(angle_betta))

        return change_in_x, change_in_y  # Return small changes in x and y for the new vertices  that should create a
        # road network

    def closest_distance_point_list(self, feature_point_list, road_feature_point_list, start_point, nearest_vertex):

        # TODO: road_feature_point_list[0] should be automated, it is suppose to be the shortest distance from
        #  the split-line point

        # print(nearest_vertex)

        clockwise_endpoint = feature_point_list.index(nearest_vertex)
        # nearest_feature_index = road_feature_point_list.index(nearest_vertex)
        # print(nearest_feature_index)
        # print(clockwise_endpoint)

        # print("Real nearest distance", nearest_vertex)
        # print("clockwise_endpoint", road_feature_point_list[clockwise_endpoint])
        # print("road_feature_point_list", road_feature_point_list)
        # print("Nearest road", road_feature_point_list[0])
        # print("feature_point_list", feature_point_list)

        while start_point > clockwise_endpoint:
            road_feature_point_list = rearrange_list(road_feature_point_list, 1, 0)
            clockwise_endpoint = feature_point_list.index(road_feature_point_list[1])

        try:
            anticlockwise_endpoint = feature_point_list.index(road_feature_point_list[-1])
        except ValueError:
            anticlockwise_endpoint = feature_point_list.index(road_feature_point_list[-2])
        # print(feature_point_list, "\n\n", road_feature_point_list)
        # print(clockwise_endpoint, anticlockwise_endpoint)
        # print(road_feature_point_list)
        # TODO: Create a function to automatically identify the nearest vertex

        # def near_road_vertex()
        self.nearest_road_vertex = road_feature_point_list[0]

        vertex_end_point = anticlockwise_endpoint - len(feature_point_list)

        clockwise_vertex_list = feature_point_list[start_point:clockwise_endpoint + 1]
        anticlockwise_vertex_list = reverse_rearrange_list(feature_point_list, start_point, vertex_end_point)
        print(feature_point_list)
        if start_point > anticlockwise_endpoint:
            anticlockwise_vertex_list = reverse_rearrange_list(feature_point_list, start_point, anticlockwise_endpoint
                                                               )

        clockwise_distance = distance_in_chain_of_vertices(clockwise_vertex_list)
        anticlockwise_distance = distance_in_chain_of_vertices(anticlockwise_vertex_list)
        # print(clockwise_distance, anticlockwise_distance)
        if clockwise_distance <= anticlockwise_distance:
            fast_point = feature_point_list[start_point - 1]
            last_point = feature_point_list[clockwise_endpoint + 1]
            clockwise_vertex_list.insert(0, fast_point)
            self.clockwise_road_direction = True
            clockwise_vertex_list.append(last_point)
            return clockwise_vertex_list
        else:
            fast_point = feature_point_list[start_point + 1]

            if start_point > anticlockwise_endpoint:
                last_point = feature_point_list[anticlockwise_endpoint - 1]
            else:
                last_point = feature_point_list[vertex_end_point - 1]

            anticlockwise_vertex_list.insert(0, fast_point)
            anticlockwise_vertex_list.append(last_point)
            self.clockwise_road_direction = False
            return anticlockwise_vertex_list

    # TODO: This method should be checked. it should calculate linear distance not radial distance
    # this method has not been used
    @staticmethod
    def road_selected_feature_coordinates_list(feat_vert, road_vertices):
        road_selected_feature_point_list = []
        for vertex in feat_vert:
            if vertex in road_vertices:
                road_selected_feature_point_list.append(vertex)
        road_selected_feature_point_list = remove_duplicates_in_list(road_selected_feature_point_list)

        return road_selected_feature_point_list  # Return point objects of vertices of selected feature that touch road

    def points_creating_new_road(self, coordinate, feat_vert, road_vertices, nearest_vertex):

        shared_coordinate_list = road_vertices  # self.road_selected_feature_coordinates_list(feat_vert, road_vertices)
        selected_feature_vertices_list = remove_duplicates_in_list(feat_vert)
        # print(coordinate)
        vertex_id = selected_feature_vertices_list.index(coordinate)
        initial_index = vertex_id - 1
        last_index = initial_index - 1
        selected_feature_vertices_list = rearrange_list(selected_feature_vertices_list, initial_index, last_index)
        # print(selected_feature_vertices_list)

        starting_point_id = selected_feature_vertices_list.index(coordinate)
        # print(starting_point_id)

        initial_index = starting_point_id

        points_to_create_road = self.closest_distance_point_list(selected_feature_vertices_list,
                                                                 shared_coordinate_list, initial_index, nearest_vertex)
        # print(points_to_create_road)

        return points_to_create_road  # Returns all feature_point_list from the vertex of the new feature to the
        # closest point of road Where the initial value of the list is the corner of the newly created feature while
        # the last value of the list is closest road location

    def road_corner_creator(self, major_corner_coordinate, corner_direction, corner_position):

        road_corner_width = self.road_width * (1 / 3)
        major_x_coordinate = major_corner_coordinate[0]
        major_y_coordinate = major_corner_coordinate[1]

        if corner_position == "top" and corner_direction == "positive":
            top_x_coordinate = major_x_coordinate + road_corner_width
            top_y_coordinate = major_y_coordinate
            bottom_x_coordinate = major_x_coordinate
            bottom_y_coordinate = major_y_coordinate - road_corner_width

            return (top_x_coordinate, top_y_coordinate), (bottom_x_coordinate, bottom_y_coordinate)

        elif corner_position == "top" and corner_direction == "negative":
            top_x_coordinate = major_x_coordinate - road_corner_width
            top_y_coordinate = major_y_coordinate
            bottom_x_coordinate = major_x_coordinate
            bottom_y_coordinate = major_y_coordinate - road_corner_width

            return (top_x_coordinate, top_y_coordinate), (bottom_x_coordinate, bottom_y_coordinate)

        elif corner_position == "bottom" and corner_direction == "positive":
            top_x_coordinate = major_x_coordinate
            top_y_coordinate = major_y_coordinate + road_corner_width
            bottom_x_coordinate = major_x_coordinate - road_corner_width
            bottom_y_coordinate = major_y_coordinate

            return (top_x_coordinate, top_y_coordinate), (bottom_x_coordinate, bottom_y_coordinate)

        elif corner_position == "bottom" and corner_direction == "negative":
            top_x_coordinate = major_x_coordinate
            top_y_coordinate = major_y_coordinate + road_corner_width
            bottom_x_coordinate = major_x_coordinate + road_corner_width
            bottom_y_coordinate = major_y_coordinate

            return (top_x_coordinate, top_y_coordinate), (bottom_x_coordinate, bottom_y_coordinate)  # returns new
            # coordinates that form new road corner

    @staticmethod
    def neighbouring_road_to_parcel(selected_layer_object, selected_feature_object, field_name):
        # layer_names, object_list = get_layer_names_and_objects()
        # layer_object = object_list[layer_names.index("land_with_roads")]
        # selected_feature_object_list = selected_layer_object.selectedFeatures()

        index = QgsSpatialIndex()

        feature_list = []
        for feature in selected_layer_object.getFeatures():
            index.insertFeature(feature)
            feature_list.append(feature)

        intersecting_feature_name_list = []
        # for selected_feature_object in selected_feature_object_list:
        selected_feature_id = selected_feature_object.id()
        selected_feature_index = None
        feature_id_list = []
        for feature in feature_list:
            feature_id_list.append(feature.id())
            if feature.id() == selected_feature_id:
                selected_feature_index = feature_list.index(feature)
        geom = selected_feature_object.geometry()
        intersecting_feature_ids = index.intersects(geom.boundingBox())
        for intersecting_feature_id in intersecting_feature_ids:
            intersecting_feature_index = feature_id_list.index(intersecting_feature_id)
            intersecting_feature = feature_list[intersecting_feature_index]
            if intersecting_feature != feature_list[selected_feature_index] \
                    and not intersecting_feature.geometry().disjoint(geom):
                field_content = intersecting_feature[field_name]
                print(field_content)
                if not isinstance(field_content, int):
                    if field_content.isalpha():
                        field_content = field_content.lower()
                    elif field_content.isalnum():
                        for later in field_content:
                            if field_content.isalpha():
                                new_later = later.lower()
                                field_content.replace(later, new_later)
                else:
                    print("Make sure that parcel names are either alphabet or alphanumeric only")
                    break
                intersecting_feature_name_list.append(field_content)

        return "rd" in intersecting_feature_name_list or "road" in intersecting_feature_name_list

    def road_geometry_with_feeders(self, shared_vertices, road_length, road_feature):

        def vertex_creator(bearing, vertex, road_len):
            vertex_x_coord = vertex.x()
            vertex_y_coord = vertex.y()
            change_in_x = road_len * sin(radians(bearing))
            change_in_y = road_len * cos(radians(bearing))
            new_vertex_x_coord = vertex_x_coord + change_in_x
            new_vertex_y_coord = vertex_y_coord + change_in_y
            return QgsPoint(new_vertex_x_coord, new_vertex_y_coord)

        def vertex_4_creator(bearing, feature_vertices, road_vertex_1_index):
            lst_len = len(self.vertices_to_remove)
            first_vertex = feature_vertices[road_vertex_1_index]

            # print("kim", feature_vertices)
            other_road_vertex = feature_vertices[road_vertex_1_index + 1]
            # print("ki", other_road_vertex.id())
            road_bearing = line_bearing(first_vertex, other_road_vertex)
            angle_theta = road_bearing - bearing
            change_in_x = (self.road_width * sin(radians(road_bearing))) / sin(radians(angle_theta))
            change_in_y = (self.road_width * cos(radians(road_bearing))) / sin(radians(angle_theta))

            if lst_len > 0:
                line_vertex_1 = feature_vertices[road_vertex_1_index + lst_len]
                line_vertex_2 = feature_vertices[road_vertex_1_index + lst_len + 1]
                initial_line = get_gradient_y_intercept(first_vertex, other_road_vertex)
                last_line = get_gradient_y_intercept(line_vertex_1, line_vertex_2)
                x_coord = 0
                y_coord = 0
                # TODO: Find a way you can solve this when the loop is greater than one
                if initial_line[0] is None or last_line[0] is None:
                    if initial_line[0] is None:
                        x_coord = initial_line[1]
                        y_coord = last_line[0] * x_coord + last_line[1]
                        # if y_coord
                    elif last_line[0] is None:
                        x_coord = last_line[1]
                        y_coord = initial_line[0] * x_coord + initial_line[1]
                else:
                    x_coord = (last_line[1] - initial_line[1]) / (initial_line[0] - last_line[0])
                    y_coord = initial_line[0] * x_coord + initial_line[1]
                return QgsPoint(x_coord, y_coord)

            first_vertex_x_coord = first_vertex.x()
            first_vertex_y_coord = first_vertex.y()
            other_vertex_x_coord = other_road_vertex.x()
            other_vertex_y_coord = other_road_vertex.y()

            max_change_in_x = other_vertex_x_coord - first_vertex_x_coord
            max_change_in_y = other_vertex_y_coord - first_vertex_y_coord

            if change_in_x > max_change_in_x:
                print("loop over")
                # road_vertex_1_index += 1
                self.vertices_to_remove.append(other_road_vertex)
                return vertex_4_creator(bearing, feature_vertices, road_vertex_1_index)
            else:
                # print(change_in_x, change_in_y)
                lst_len = len(self.vertices_to_remove)
                if lst_len > 0:
                    first_vertex_x_coord = feature_vertices[road_vertex_1_index - lst_len - 1].x()
                    first_vertex_y_coord = feature_vertices[road_vertex_1_index - lst_len].y()
                x_coord = first_vertex_x_coord + change_in_x
                y_coord = first_vertex_y_coord + change_in_y
                return QgsPoint(x_coord, y_coord)

            # print(max_change_in_x, change_in_x)
            # print(max_change_in_y, change_in_y)

        initial_line_vertex = shared_vertices[0]
        # print(initial_line_vertex)
        last_line_vertex = shared_vertices[1]
        bearing_of_road = line_bearing(last_line_vertex, initial_line_vertex)

        road_feature_geometry = road_feature.geometry()
        road_feature_vertices = [vertex for vertex in road_feature_geometry.vertices()]
        road_feature_vertices = remove_duplicates_in_list(road_feature_vertices)
        first_road_vertex = road_feature_vertices[0]

        # if nw_rd_vert is not None:
        #     vertices_to_remove = []
        #     for feature_vertex in road_feature_vertices:
        #         if feature_vertex not in nw_rd_vert:
        #             vertex_to_remove = road_feature_vertices.index(feature_vertex)
        #             road_feature_geometry.deleteVertex(vertex_to_remove)

        road_feature_vertices = [vertex for vertex in road_feature_geometry.vertices()]
        road_feature_vertices = remove_duplicates_in_list(road_feature_vertices)
        first_road_vertex = road_feature_vertices[0]

        for shared_vertex in shared_vertices:
            if shared_vertex in road_feature_vertices:
                initial_line_vertex = shared_vertex

        road_vertex_index = road_feature_vertices.index(initial_line_vertex)
        vertex_2 = vertex_creator(bearing_of_road, initial_line_vertex, road_length)
        road_perpendicular_bearing = bearing_of_road + 90
        vertex_3 = vertex_creator(road_perpendicular_bearing, vertex_2, self.road_width)
        vertex_4 = vertex_4_creator(bearing_of_road, road_feature_vertices, road_vertex_index)
        # print(road_feature_vertices, road_vertex_index)
        # print(vertex_4)
        # print(vertex_2, vertex_3)
        new_vertices = [vertex_2, vertex_3, vertex_4]
        rearranged_road_vertices = rearrange_list(road_feature_vertices, road_vertex_index + 1, road_vertex_index)
        rearranged_road_vertices = remove_duplicates_in_list(rearranged_road_vertices)
        new_road_vertices = new_vertices + rearranged_road_vertices
        for vertex in self.vertices_to_remove:
            new_road_vertices.remove(vertex)
            self.vertices_to_remove.remove(vertex)
        first_road_vertex_index = new_road_vertices.index(first_road_vertex)
        new_road_vertices = rearrange_list(new_road_vertices, first_road_vertex_index, first_road_vertex_index - 1)
        # print(first_road_vertex_index)
        converted_new_road_points = convert_from_point_to_pointxy(new_road_vertices)
        new_road_geometry = QgsGeometry.fromPolygonXY([converted_new_road_points])
        # print(road_feature_vertices)
        # print(new_road_vertices)

        return new_road_geometry, new_vertices

    def major_subdivision_road_creator(self, boundary_vertex, feat_vert, road_vertices, nearest_vertex):
        # TODO: Connect road id to the gui # Done
        points_creating_points_list = self.points_creating_new_road(boundary_vertex, feat_vert, road_vertices, nearest_vertex)
        new_points_creating_vertices_list = []
        count = 0
        number_of_loops = len(points_creating_points_list) - 1
        bearing_remainder = 0
        stored_bearings = []
        # print(points_creating_points_list)
        while count <= number_of_loops:
            remaining_value = number_of_loops - count
            first_point = points_creating_points_list[count]
            if remaining_value > 0:
                middle_point = points_creating_points_list[count + 1]
                if remaining_value > 1:
                    last_point = points_creating_points_list[count + 2]
                    bearing_1 = line_bearing(middle_point, first_point)
                    bearing_2 = line_bearing(middle_point, last_point)
                    change_in_coordinates = self.parallel_line_coordinate_change(bearing_1, bearing_2)
                    x_coordinate = middle_point.x()
                    y_coordinate = middle_point.y()

                    if remaining_value == 2:
                        bearing_difference = abs(bearing_2 - bearing_1)
                        bearing_remainder = abs(180 - bearing_difference)
                else:
                    # TODO: IDENTIFY WHAT THIS DOE
                    if 30 < bearing_remainder < 150:
                        pass
                        # print(stored_bearings)
                    self.initial_points = True
                    last_point = middle_point
                    bearing = line_bearing(first_point, last_point)
                    change_in_coordinates = self.parallel_line_coordinate_change(bearing)
                    x_coordinate = first_point.x()
                    y_coordinate = first_point.y()

            # TODO: If angle_1 - angle_2 is less than 60 or greater that 120 self.final points should be True

            else:
                last_point = first_point
                first_point = points_creating_points_list[count - 1]
                bearing = line_bearing(first_point, last_point)
                change_in_coordinates = self.parallel_line_coordinate_change(bearing)
                x_coordinate = first_point.x()
                y_coordinate = first_point.y()
            change_in_x = change_in_coordinates[0]
            change_in_y = change_in_coordinates[1]
            new_x_coordinate = x_coordinate + change_in_x
            new_y_coordinate = y_coordinate + change_in_y
            new_vertex = QgsPoint(new_x_coordinate, new_y_coordinate)
            new_points_creating_vertices_list.append(new_vertex)

            count += 1
        # print(new_points_creating_vertices_list, "\n")
        # #### trial
        # Reshaping the feature to accommodate road
        vertices_from_selected_point_to_road = points_creating_points_list[1:-1]
        # print(vertices_from_selected_point_to_road)

        # initial_vertex_id_to_edit = vertices_from_selected_point_to_road[0]
        # selected_feature = [feature for feature in selected_layer.selectedFeatures()][0]
        # selected_feature_geometry = selected_feature.geometry()
        # selected_feature_vertices = selected_feature_geometry.vertices()
        # # selected_feature_vertex_point_list = [vertex for vertex in selected_feature_vertices]
        # # selected_feature_vertex_point_list = remove_duplicates_in_list(selected_feature_vertex_point_list)
        # initial_index = feat_vert.index(initial_vertex_id_to_edit)
        # first_index = initial_index
        # last_index = initial_index - len(feat_vert)

        # if not self.clockwise_road_direction:
        # selected_feature_vertex_point_list = reverse_rearrange_list(feat_vert, first_index,
        # last_index)

        # initial_index = feat_vert.index(initial_vertex_id_to_edit)

        # layer_data_provider = selected_layer.dataProvider()

        # print(selected_feature_vertex_point_list, "\n")
        # feat_vert = remove_duplicates_in_list(feat_vert)
        # for vertex in vertices_from_selected_point_to_road:
        #     feat_vert.remove(vertex)
        # print(feat_vert)
        #
        # for vertex in new_points_creating_vertices_list:
        #     feat_vert.insert(initial_index, vertex)
        #     initial_index += 1
        #
        # if not self.clockwise_road_direction:
        #     feat_vert.reverse()

        # feature_id = selected_feature.id()
        # print(selected_feature_vertex_point_list)
        # converted_vertex_point_list = convert_from_point_to_pointxy(feat_vert)
        # new_feature_polygon = QgsGeometry.fromPolygonXY([converted_vertex_point_list])
        # layer_data_provider.changeGeometryValues({feature_id: new_feature_polygon})

        # code below creates new road in feature
        if self.clockwise_road_direction:
            new_points_creating_vertices_list.reverse()
        else:
            vertices_from_selected_point_to_road.reverse()

        new_road_points = vertices_from_selected_point_to_road + new_points_creating_vertices_list
        # print(new_road_points)
        # converted_new_road_points = convert_from_point_to_pointxy(new_road_points)
        # new_road_polygon = QgsGeometry.fromPolygonXY([converted_new_road_points])
        # layer_data_provider.changeGeometryValues({road_id: new_road_polygon})
        return new_road_points, new_points_creating_vertices_list, vertices_from_selected_point_to_road


class SubdivisionCreator:
    def __init__(self, size_of_each_parcels, number_of_parcels, road_width, output_file_path, parcel_position,
                 division_direction, identified_layer, selected_feature_object, area_units_used, length_unit_used,
                 coordinate_system, selected_road_name, column_name, selected_road_index):

        # variables from the constructor
        self.size_of_each_parcels = size_of_each_parcels
        self.number_of_parcels = number_of_parcels
        self.road_width = road_width
        self.selected_road_name = selected_road_name
        self.column_name = column_name
        self.output_file_path = output_file_path
        # self.parcel_position = parcel_position
        # self.division_direction = division_direction
        self.selected_layer = identified_layer
        self.selected_feature_object = selected_feature_object
        # self.area_units_used = area_units_used
        # self.length_unit_used = length_unit_used
        # self.coordinate_system = coordinate_system
        self.selected_road_index = selected_road_index

        # Lists
        self.feature_creation_counter_list = []

        # variables
        self.size_in_metres_square = self.size_of_each_parcels * 4046.86
        self.width = sqrt(self.size_in_metres_square / 2)
        self.length = self.width * 2
        self.buffer = 1e-6
        self.subdivision_area = 1  # 1 gives a true value while 0 gives a false value
        self.parcel_counter = 1
        self.major_subdivision_counter = 0
        self.minor_subdivision_counter = 0
        self.final_feature_id = 0
        self.feature_count = 0
        self.list_of_shared_vertices = None
        self.vertex_1_to_create_road = None
        self.road_top_y_coord = []
        self.other_feature_id = None
        self.create_new_road = False
        self.repeat_feature_id = 0
        self.no_subdivision = False
        self.selected_vertex = 0

        # booleans
        self.exit_major_division_loop = False

        # constructors
        self.road_creator_constructor = RoadNetworkCreator(self.road_width)

    @staticmethod
    def area_of_parcel_in_acres(feature):  # change this name to new shapefile area and change created_new
        # shapefiles to new
        # shapefiles
        area = feature.geometry().area()  # area in metres square
        one_acre_in_metres_square = 4046.86
        area_in_acres = round(area / one_acre_in_metres_square, 2)
        return area_in_acres

    @staticmethod
    def splitting_line_1(movable_coordinates, fixed_coordinates, selected_feature_object):
        # this function should return the total area of the major subdivision parcel

        selected_feature_geometry = QgsGeometry(selected_feature_object.geometry())  # This a deep copy of geometry

        split_points_list = [QgsPointXY(movable_coordinates, round(fixed_coordinates[0], 7)),  # This is the lower
                             # coordinate that will create the split line
                             QgsPointXY(movable_coordinates, round(fixed_coordinates[1], 7))]  # This is the upper
        # coordinate that will create the split line

        base, divided_polygons, topology_list = selected_feature_geometry.splitGeometry(split_points_list, False)
        divided_polygons.append(selected_feature_geometry)

        return base, divided_polygons

    @staticmethod
    def splitting_line(movable_coordinates, fixed_coordinates, selected_feature_object):
        # this function should return the total area of the major subdivision parcel

        selected_feature_geometry = QgsGeometry(selected_feature_object.geometry())  # This a deep copy of geometry

        split_points_list = [QgsPointXY(round(fixed_coordinates[0], 7), movable_coordinates),
                             QgsPointXY(round(fixed_coordinates[1] + 1, 7), movable_coordinates)]

        base, divided_polygons, topology_list = selected_feature_geometry.splitGeometry(split_points_list, False)
        divided_polygons.append(selected_feature_geometry)

        return base, divided_polygons

    def check_area(self, movable_coordinates, fixed_coordinates, selected_feature_object):
        # This function creates a new parcel and portion depending on the size of a single plot

        list_of_created_geometries = []
        generated_polygons = self.splitting_line(movable_coordinates, fixed_coordinates, selected_feature_object)

        base = generated_polygons[0]
        divided_polygons = generated_polygons[1]

        if base == 0 and len(divided_polygons) > 1:
            for polygon_number in range(len(divided_polygons)):
                # y_max_polygon_bound = divided_polygons[polygon_number].boundingBox().yMaximum()
                created_subdivision = divided_polygons[polygon_number]  # this is a selected geometry area
                list_of_created_geometries.append(created_subdivision)  # this creates a list of all the geometric
                # features in the layer
                selected_feature_object.setGeometry(created_subdivision)  # making a geometry to be a feature

            # TODO: determine the side in which the new feature lies
            self.subdivision_area = list_of_created_geometries[1].area()
            self.subdivision_area = self.subdivision_area / 4046.86
            self.subdivision_area = round(self.subdivision_area, 6)
        else:
            print("base is 1000")

    def check_area_1(self, movable_coordinates, fixed_coordinates, selected_feature_object):
        # This function creates a new parcel and portion depending on the size of a single plot

        list_of_created_geometries = []
        generated_polygons = self.splitting_line_1(movable_coordinates, fixed_coordinates, selected_feature_object)

        base = generated_polygons[0]
        divided_polygons = generated_polygons[1]

        if base == 0 and len(divided_polygons) > 1:
            for polygon_number in range(len(divided_polygons)):
                # y_max_polygon_bound = divided_polygons[polygon_number].boundingBox().yMaximum()
                created_subdivision = divided_polygons[polygon_number]  # this is a selected geometry area
                list_of_created_geometries.append(created_subdivision)  # this creates a list of all the geometric
                # features in the layer
                selected_feature_object.setGeometry(created_subdivision)  # making a geometry to be a feature

            # TODO: determine the side in which the new feature lies
            self.subdivision_area = list_of_created_geometries[0].area()
            self.subdivision_area = self.subdivision_area / 4046.86
            self.subdivision_area = round(self.subdivision_area, 6)

    @staticmethod
    def delete_feature(layer, feature_id):
        layer.startEditing()
        layer.deleteFeature(feature_id)
        layer.commitChanges()

    @staticmethod
    def selected_feature(layer_object, feature_id):
        selected_features_object = [new_feature for new_feature in layer_object.getFeatures()]
        selected_features_object = selected_features_object[feature_id - 1]

        return selected_features_object

    @staticmethod
    def binding_box(feature_object):
        parcel_binding_box = feature_object.geometry().boundingBox()
        parcel_bounds = [parcel_binding_box.xMinimum(), parcel_binding_box.yMinimum(), parcel_binding_box.xMaximum(),
                         parcel_binding_box.yMaximum()]

        return parcel_bounds  # returns x-minimum  followed by y-minimum then x-maximum and lastly y-maximum

    def minor_subdivisions(self, layer_object, attribute_object, feature_id):
        # if len(self.feature_creation_counter_list) > 0:
        #     if self.feature_creation_counter_list[-1] == 1:
        #         self.feature_count += 1  # to remove major subdivision feature from the count
        self.selected_road_index = 2

        feature_id_list = [feature.id() for feature in layer_object.getFeatures()]
        last_feature_id = feature_id_list[-1]
        if self.subdivision_area != self.size_of_each_parcels:

            parcels_in_subdivision = ceil(self.subdivision_area / self.size_of_each_parcels)  # This may create
            # less subdivision number if the subdivision is greater than a whole number by a very small margin
            number_of_splitlines = int(parcels_in_subdivision - 1)
            selected_feature_object = layer_object.getFeatures(QgsFeatureRequest().setFilterFid(feature_id))

            selected_feature_object = next(selected_feature_object)

            parcel_bounds = self.binding_box(selected_feature_object)

            min_x_bound = parcel_bounds[0] - 1
            min_y_bound = parcel_bounds[1] - 1
            max_x_bound = parcel_bounds[2] + 1
            max_y_bound = parcel_bounds[3] + 1

            interval_coordinates = min_y_bound + self.buffer, max_y_bound - self.buffer  # This gives a tuple of
            # feature_point_list that can change. The values that change are the x-coordinates
            fixed_coordinates = min_x_bound, max_x_bound  # This gives a tuple of feature_point_list
            # that are fixed. The values that are fixed are the y-coordinates

            # This divides from the left to the right

            power_value = len(str(floor(self.length))) - 1
            width_to_add = 10 ** power_value  # This is the value to increment when the requires area and the area of
            # the parcel are n ot equal)]

            incremented_movable_coordinate = interval_coordinates[0] + width_to_add

            feature_id -= 1
            max_parcels = self.number_of_parcels
            projected_no_of_parcels = self.feature_count + number_of_splitlines + 1

            if projected_no_of_parcels >= max_parcels:
                if projected_no_of_parcels > max_parcels:
                    extra_parcels = projected_no_of_parcels - max_parcels
                    number_of_splitlines = number_of_splitlines - extra_parcels + 1
                self.exit_major_division_loop = True

            for split_line_number in range(number_of_splitlines):

                feature_ids_list = [feature.id() for feature in layer_object.getFeatures()]

                select_feature_id = feature_ids_list.index(feature_id + 1) + 1
                selected_features_object = self.selected_feature(layer_object, select_feature_id)  # why is feature id
                # is subtracted by 1 at this point

                self.check_area(incremented_movable_coordinate, fixed_coordinates, selected_features_object)

                m = 0

                while self.subdivision_area != self.size_of_each_parcels:

                    if m == 100:
                        break

                    selected_features_object = self.selected_feature(layer_object, select_feature_id)

                    if self.subdivision_area < self.size_of_each_parcels:

                        self.check_area(incremented_movable_coordinate, fixed_coordinates, selected_features_object)

                        if self.subdivision_area < self.size_of_each_parcels:
                            incremented_movable_coordinate += width_to_add

                    elif self.subdivision_area > self.size_of_each_parcels:
                        incremented_movable_coordinate -= width_to_add

                        self.check_area(incremented_movable_coordinate, fixed_coordinates, selected_features_object)
                        width_to_add *= 0.1

                    m += 1

                layer_object.select(feature_ids_list[select_feature_id - 1])

                # create_new_features(create_new_shapefile, initial_movable_coordinates, fixed_coordinates,
                # selected_feature)
                # if remaining area is equal to 0 then save the file in the create new feature function

                selected_features_object = self.selected_feature(layer_object, select_feature_id)
                generated_polygons = self.splitting_line(incremented_movable_coordinate, fixed_coordinates,
                                                         selected_features_object)
                base = generated_polygons[0]
                divided_polygons = generated_polygons[1]

                if base == 0 and len(divided_polygons) > 1:
                    for polygon_number in range(len(divided_polygons)):
                        created_subdivision = divided_polygons[polygon_number]
                        selected_features_object.setGeometry(created_subdivision)
                        selected_feature_area = selected_features_object.geometry().area() / 4046.86
                        selected_feature_area = round(selected_feature_area, 4)
                        selected_features_object.setAttributes([f"Parcel {self.parcel_counter}", selected_feature_area])

                        layer_object.updateExtents()

                        attribute_object.addFeature(selected_features_object)

                        self.parcel_counter += 1

                self.road_top_y_coord.append(incremented_movable_coordinate)
                # print("\n", [feature.id() for feature in layer_object.getFeatures()])

                # print("Feature id to be deleted at minor subdivision = ", feature_id + 1)

                feature_id_tobe_deleted = feature_id + 1

                self.delete_feature(layer_object, feature_id_tobe_deleted)

                layer_object.updateFields()

                feature_ids_list = [feature.id() for feature in layer_object.getFeatures()]
                feature_id = feature_ids_list[-2] - 1

                width_to_add = 10 ** power_value

                incremented_movable_coordinate += width_to_add

                # layer_object.select(8)
                self.minor_subdivision_counter += 1

                # TODO: This is where The last parcel is created so that it fits

            if self.exit_major_division_loop:
                feature_ids = [feature.id() for feature in layer_object.getFeatures()]
                feature_1_index = len(feature_ids) - 2
                feature_2_index = feature_ids.index(last_feature_id)
                feature_1 = self.selected_feature(layer_object, feature_1_index + 1)
                feature_1_geometry = feature_1.geometry()
                feature_2_geometry = self.selected_feature(layer_object, feature_2_index + 1).geometry()
                new_feature_geometry = feature_2_geometry.combine(feature_1_geometry)
                attribute_object.changeGeometryValues({last_feature_id: new_feature_geometry})
                self.delete_feature(layer_object, feature_ids[-2])
                feature_object = self.selected_feature(layer_object, feature_2_index + 1)

                layer_object.startEditing()
                feature_object["Area"] = round(feature_object.geometry().area() / 4046.86, 4)
                layer_object.updateFeature(feature_object)
                layer_object.commitChanges()
                # print("New geometry:", new_feature_geometry)
                # print("Feature isd 2", feature_1_index, feature_2_index)

            self.feature_count += self.minor_subdivision_counter
            # print("Number of parcels ", self.feature_count)

        else:
            if self.feature_count == self.number_of_parcels - 1:
                self.exit_major_division_loop = True
            else:
                self.feature_count += 1
                # print("Number of parcels ", self.feature_count)
                print('Major subdivision is equal to minor subdivision')

    def major_subdivision_1(self, feature_id, created_layer, attribute_object, selected_feature_object):
        # this function creates a major division of parcels.
        # The major division is the division where the minor divisions will be generated.
        # The major divisions is the one responsible for the creation of road networks within the
        # new parcels that will be formed
        # This part will be able to create a line that subdivides the parcels, a function to calculate the created
        # parcels and a function responsible for adjusting width to get a perfect are
        # global nw_rd_vert

        self.minor_subdivision_counter = 1

        parcel_bounds = self.binding_box(selected_feature_object)

        min_x_bound = parcel_bounds[0] - 1  # 1 is subtracted so that the buffer can be accommodated
        min_y_bound = parcel_bounds[1] - 1  # 1 is subtracted so that the buffer can be accommodated
        max_x_bound = parcel_bounds[2] + 1  # 1 is added so that the buffer can be accommodated
        max_y_bound = parcel_bounds[3] + 1  # 1 is added so that the buffer can be accommodated

        interval_coordinates = min_x_bound + self.buffer, max_x_bound - self.buffer  # This gives a tuple of
        # feature_point_list that can change. The values that change are the x-coordinates
        fixed_coordinates = min_y_bound, max_y_bound  # This gives a tuple of feature_point_list
        # that are fixed. The values that are fixed are the y-coordinates

        # TODO: if max_x - min_x > 5 so as to specify the minimum length or width of plots

        # TODO: The width has a problem, review it

        while max_x_bound - min_x_bound <= self.width:
            self.width = self.width * 0.5
        # road_x_coordinate = self.vertex_1_to_create_road.x()

        if max_x_bound - min_x_bound > 12.5:  # also consider the other part of the subdivision
            # where width is greater than the total width of the parcel
            # at this point you should calculate the area of each slice
            incremented_movable_coordinate = interval_coordinates[0] + self.width  # This is where sub-division
            # starts from the bottom of the parcel. This coordinates creates a new division of the parcel

            self.check_area_1(incremented_movable_coordinate, fixed_coordinates, selected_feature_object)

            # TODO: Consider zero division
            # print(self.no_subdivision)

            # if self.no_subdivision:
            # print(ceil(self.subdivision_area / self.size_of_each_parcels))
            parcels_in_major_subdivision = ceil(self.subdivision_area / self.size_of_each_parcels)

            if self.size_of_each_parcels < 0.5:
                parcels_in_major_subdivision = parcels_in_major_subdivision + 2

            if self.create_new_road and self.subdivision_area < 1:
                # TODO: trouble in creating smaller parcels
                pass
                # This divides
            # the size of  the new created feature by the size of parcel needed.
            major_subdivision_required_area = round(self.size_of_each_parcels * parcels_in_major_subdivision, 6)
            power_value = len(str(floor(self.width))) - 1
            width_to_add = 10 ** power_value  # This is the value to increment when the requires area and the area of
            # the parcel are n ot equal

            # This is the point where you should add an exception where the width should be between the maximum
            # and minimum values

            incremented_movable_coordinate = interval_coordinates[0] + self.width + width_to_add

            c = 0

            while self.subdivision_area != major_subdivision_required_area:

                selected_feature_object = self.selected_feature(created_layer, feature_id)

                if c == 500:
                    print("exit loop")
                    break

                if self.subdivision_area > major_subdivision_required_area or \
                        incremented_movable_coordinate > interval_coordinates[1] + 1:
                    incremented_movable_coordinate -= width_to_add

                    self.check_area_1(incremented_movable_coordinate, fixed_coordinates, selected_feature_object)
                    width_to_add *= 0.1

                elif incremented_movable_coordinate == interval_coordinates[1] + 1:
                    # print("Equal")
                    break

                elif self.subdivision_area < major_subdivision_required_area:
                    self.check_area_1(incremented_movable_coordinate, fixed_coordinates, selected_feature_object)

                    if self.subdivision_area < major_subdivision_required_area:
                        incremented_movable_coordinate += width_to_add

                # print(interval_coordinates[1], "n", incremented_movable_coordinate - 1)
                # print(interval_coordinates[1])

                c += 1
            # else:
            #     incremented_movable_coordinate = self.selected_vertex
            #     incremented_movable_coordinate = convert_from_point_to_pointxy([incremented_movable_coordinate])
            #     incremented_movable_coordinate = incremented_movable_coordinate[0][0]
            # print("ir2", incremented_movable_coordinate)

            self.parcel_counter += 1

            # if remaining area is equal to 0 then save the file in the create new feature function

            if incremented_movable_coordinate != interval_coordinates[1] + 1:

                selected_feature_object = self.selected_feature(created_layer, feature_id)
                generated_polygons = self.splitting_line_1(incremented_movable_coordinate, fixed_coordinates,
                                                           selected_feature_object)
                base = generated_polygons[0]
                divided_polygons = generated_polygons[1]
                # print(divided_polygons)
                feature_1_geometry = divided_polygons[0]
                feature_2_geometry = divided_polygons[1]

                if self.major_subdivision_counter == 1:
                    road_index = 1
                else:
                    road_index = 0

                road_feature = self.selected_feature(created_layer, road_index + 1)
                road_geometry = road_feature.geometry()
                road_feature_vertex_list = [vertex for vertex in road_feature.geometry().vertices()]
                # print(road_feature_vertex_list)

                list_of_shared_vertices = feature_shared_vertices(feature_2_geometry, feature_1_geometry)
                list_of_shared_vertices = remove_duplicates_in_list(list_of_shared_vertices)
                self.list_of_shared_vertices = list_of_shared_vertices
                for vertex_point in list_of_shared_vertices:
                    count = 0
                    points_of_line_list = []
                    while count < len(road_feature_vertex_list) - 1:
                        line_vertices = [road_feature_vertex_list[count], road_feature_vertex_list[count + 1]]
                        point_on_line = point_in_line(line_vertices, vertex_point)
                        if point_on_line:
                            print(line_vertices, vertex_point)

                        if point_on_line:
                            points_of_line_list.append(line_vertices)
                        count += 1
                    # print(road_feature_vertex_list)
                    x_coord = 0
                    y_coord = 0
                    point_index = 0
                    for points_of_line in points_of_line_list:
                        point_to_insert_vertex = points_of_line[1]
                        print(point_to_insert_vertex)
                        point_index = road_feature_vertex_list.index(point_to_insert_vertex)
                        x_coord = vertex_point.x()
                        y_coord = vertex_point.y()
                        # print(x_coord)
                        # print(y_coord)
                    if x_coord != 0 or y_coord != 0:
                        road_geometry.insertVertex(x_coord, y_coord, point_index)
                        self.vertex_1_to_create_road = vertex_point
                        # print(point_index)
                    # print(road_geometry)
                attribute_object.changeGeometryValues({2: road_geometry})  # This creates the initial road
                feature_1_has_road = feature_has_road(feature_1_geometry, road_geometry)
                feature_2_has_road = feature_has_road(feature_2_geometry, road_geometry)
                # print(feature_1_geometry, feature_2_has_road)
                if feature_1_has_road and feature_2_has_road:

                    # print(total_parcel_area/self.size_of_each_parcels ,"\n",  subdivision_area /
                    # self.size_of_each_parcels) print("base", base)

                    if base == 0 and len(divided_polygons) > 1:
                        for polygon_number in range(len(divided_polygons)):
                            created_subdivision = divided_polygons[polygon_number]
                            selected_feature_object.setGeometry(created_subdivision)
                            selected_feature_area = selected_feature_object.geometry().area() / 4046.86
                            selected_feature_area = round(selected_feature_area,
                                                          4)  # round off to the nearest 4 decimals

                            selected_feature_object.setAttributes(
                                [f"Parcel {self.parcel_counter}", selected_feature_area])

                            attribute_object.addFeature(selected_feature_object)
                            created_layer.updateExtents()

                            self.parcel_counter += 1

                    feature_id_list = [feature.id() for feature in created_layer.getFeatures()]
                    feature_id_to_delete = feature_id_list[feature_id - 1]

                    # print("Feature id to be deleted at the major subdivision = ", feature_id_to_delete)

                    if self.subdivision_area / self.size_of_each_parcels >= 1 or self.no_subdivision:
                        self.delete_feature(created_layer, feature_id_to_delete)
                    created_layer.updateFields()
                    created_layer.commitChanges()

                    feature_ids_list = [feature.id() for feature in created_layer.getFeatures()]

                    major_subdivision_feature_id = feature_ids_list[
                        -2]  # The minor subdivision is always second last value
                    # print("major subdivision feature id", major_subdivision_feature_id)
                    # print("Feature id list ", feature_ids_list)
                    self.other_feature_id = feature_ids_list[-1]
                    self.no_subdivision = False

                    self.minor_subdivisions(created_layer, attribute_object, major_subdivision_feature_id)
                    self.major_subdivision_counter += 1
                    created_layer.updateFields()
                    created_layer.commitChanges()
                else:
                    # list_of_distances = []
                    # vertices_to_create_road_list = []
                    # closest_distance_index = 0
                    # print(feature_1_has_road)
                    # for vertex in list_of_shared_vertices:
                    if feature_1_has_road:
                        feature_vertices = [vertex for vertex in feature_1_geometry.vertices()]
                    else:
                        feature_vertices = [vertex for vertex in feature_2_geometry.vertices()]
                    # feature_point_index = feature_vertices.index(vertex)
                    road_vertices = [vertex for vertex in road_geometry.vertices()]
                    shared_road_feature_vertices = self.road_creator_constructor. \
                        road_selected_feature_coordinates_list(feature_vertices, road_vertices)
                    # print(shared_road_feature_vertices)
                    # print(feature_vertices)

                    road_feature_vertices = []
                    for vert in feature_vertices:
                        if vert in road_vertices:
                            road_feature_vertices.append(vert)

                    # TODO: Automate the the identification of clockwise and Anticlockwise road # This is done

                    selected_vertex = select_vertex(list_of_shared_vertices)
                    self.selected_vertex = selected_vertex

                    last_road_creating_vertex, feat_vert = selected_vertex, feature_vertices
                    road_direction, nearest_vertex = check_road_direction(selected_vertex,
                                                                          feature_vertices,
                                                                          shared_road_feature_vertices)
                    # print(nearest_vertex)

                    if road_direction == "clockwise":
                        selected_feature_geometry = selected_feature_object.geometry()
                        selected_feature_vertices = [vertex for vertex in selected_feature_geometry.vertices()]
                        selected_feature_vertices = remove_duplicates_in_list(selected_feature_vertices)
                        points_to_create_road, one_side_points, points_from_road = self.road_creator_constructor. \
                            major_subdivision_road_creator(last_road_creating_vertex, feat_vert,
                                                           shared_road_feature_vertices, nearest_vertex)
                        nearest_road_point = nearest_vertex  # self.road_creator_constructor.nearest_road_vertex
                        feat_vert_index = selected_feature_vertices.index(nearest_road_point)
                        # feat_vert = rearrange_list(selected_feature_vertices, feat_vert_index, feat_vert_index - 1)
                        for vertex in points_from_road:

                            if vertex in selected_feature_vertices:
                                selected_feature_vertices.remove(vertex)
                            else:
                                if vertex == points_from_road[-1]:
                                    one_side_points.insert(0, vertex)
                                else:
                                    pass
                        one_side_points.reverse()
                        # print(selected_feature_vertices, "\n", one_side_points)
                        new_2_feature_vertices = one_side_points + selected_feature_vertices
                        new_2_feature_vertices = convert_from_point_to_pointxy(new_2_feature_vertices)

                        # print(nearest_road_point)
                        rd_point_index = road_feature_vertex_list.index(nearest_road_point)
                        # print(points_to_create_road)
                        new_rd_point_index = points_to_create_road.index(nearest_road_point)
                        road_feature_vertex_list = rearrange_list(road_feature_vertex_list, rd_point_index,
                                                                  rd_point_index
                                                                  - 1)
                        points_to_create_road = rearrange_list(points_to_create_road, new_rd_point_index,
                                                               new_rd_point_index - 1)
                        road_feature_vertex_list.remove(nearest_road_point)
                        new_road_vertices = road_feature_vertex_list + points_to_create_road
                        new_road_vertices = remove_duplicates_in_list(new_road_vertices)
                        # print("freshest road vertices", new_road_vertices)
                        new_road_vertices = convert_from_point_to_pointxy(new_road_vertices)
                        self.no_subdivision = True


                        # print(points_to_create_road, "\n", one_side_points, "\n", points_from_road)
                    elif road_direction == "anticlockwise":
                        last_road_creating_vertex, feat_vert = final_road_vertex(selected_vertex,
                                                                                 selected_feature_object)
                        feat_vert = remove_duplicates_in_list(feat_vert)
                        points_to_create_road, one_side_points, points_from_road = self.road_creator_constructor. \
                            major_subdivision_road_creator(last_road_creating_vertex, feat_vert,
                                                           road_feature_vertices, nearest_vertex)

                        nearest_road_point = self.road_creator_constructor.nearest_road_vertex
                        # print("outer feature", feat_vert, "\n The point", nearest_road_point)
                        feat_vert_index = feat_vert.index(nearest_road_point)
                        feat_vert = rearrange_list(feat_vert, feat_vert_index, feat_vert_index - 1)

                        for vertex in points_from_road:
                            feat_vert.remove(vertex)
                        # if self.road_creator_constructor.clockwise_road_direction:
                        one_side_points.reverse()
                        new_2_feature_vertices = feat_vert + one_side_points
                        new_2_feature_vertices = convert_from_point_to_pointxy(new_2_feature_vertices)
                        # print(feat_vert)
                        # print(new_feature_geometry)

                        rd_point_index = road_feature_vertex_list.index(nearest_road_point)
                        # print(points_to_create_road)
                        # print("new_2_feature_vertices", new_2_feature_vertices)
                        new_rd_point_index = points_to_create_road.index(nearest_road_point)
                        road_feature_vertex_list = rearrange_list(road_feature_vertex_list, rd_point_index,
                                                                  rd_point_index
                                                                  - 1)
                        points_to_create_road = rearrange_list(points_to_create_road, new_rd_point_index,
                                                               new_rd_point_index - 1)
                        points_to_create_road.remove(nearest_road_point)
                        new_road_vertices = points_to_create_road + road_feature_vertex_list

                        new_road_vertices = convert_from_point_to_pointxy(new_road_vertices)

                    # new_feature_1_geometry = QgsGeometry.fromPolygonXY([new_1_feature_vertices])
                    new_feature_2_geometry = QgsGeometry.fromPolygonXY([new_2_feature_vertices])
                    new_road_geometry = QgsGeometry.fromPolygonXY([new_road_vertices])

                    attribute_object.changeGeometryValues({feature_id: new_feature_2_geometry})
                    attribute_object.changeGeometryValues({2: new_road_geometry})
                    created_layer.updateFields()
                    created_layer.commitChanges()
                    self.repeat_feature_id = feature_id
                    self.no_subdivision = True
                    # print(new_road_vertices)

            else:

                feature_ids_list = [feature.id() for feature in created_layer.getFeatures()]
                major_subdivision_feature_id = feature_ids_list[feature_id - 1]

                # print(major_subdivision_feature_id)

                self.minor_subdivisions(created_layer, attribute_object, major_subdivision_feature_id)

                self.exit_major_division_loop = True

        else:
            print("Width is too little!")

            self.exit_major_division_loop = True

    def main(self):

        # Check id a parcel has an access road. All parcels should have an access road
        if self.road_creator_constructor.neighbouring_road_to_parcel(self.selected_layer, self.selected_feature_object,
                                                                     self.column_name):

            # for layer_object in get_layer_names_and_objects()[1]:
            # TODO: show an exception if there is no layer loaded to the canvas

            try:
                # Identifying the road feature id
                road_feature_id_index = [feature.id() for feature in self.selected_layer.getFeatures()] \
                                            .index(self.selected_road_index) + 1
            except IndexError:
                print("input appropriate road feature")

            road_feature_object = self.selected_feature(self.selected_layer, road_feature_id_index)
            road_feature_geometry = road_feature_object.geometry()

            # Gets the bounding box of the parcel or feature to be subdivided. 30 is added so as to show the
            # boundaries of neibouring parcels and roads
            selected_feature_bounds = self.binding_box(self.selected_feature_object)

            min_x_bound = selected_feature_bounds[0] - 30
            min_y_bound = selected_feature_bounds[1] - 30
            max_x_bound = selected_feature_bounds[2] + 30
            max_y_bound = selected_feature_bounds[3] + 30

            clip_rectangle_object = QgsRectangle(min_x_bound, min_y_bound, max_x_bound, max_y_bound)
            # Clipping the road feature
            clipped_road_geometry = road_feature_geometry.clipped(clip_rectangle_object)

            self.major_subdivision_counter = 1  # Initialising the count of major subdivisions

            # TODO: Remove output file path below
            self.output_file_path = "C:/Users/Denis Kimaru/Documents/Subdivided.shp"
            layer_name = os.path.basename(self.output_file_path)[0:-4]

            # Grabbing the selected feature so as to add it to a new layer
            layer_from_selected_feature = self.selected_layer.materialize(QgsFeatureRequest().setFilterFids(
                [self.selected_feature_object.id()]))
            feature_copy = QgsFeature()
            # field_list = feature_copy.fields()  # creating feature fields
            # # creating a new shapefile
            # new_shapefile = QgsVectorFileWriter(self.output_file_path, "UTF-16", field_list, QgsWkbTypes.Polygon,
            #                                     layer_object.crs(), "ESRI Shapefile")

            # Creating a new layer of the parcel to be subdivided
            final_layer = QgsVectorLayer("multipolygon?crs=epsg:32637&field=name:string(20)&index=yes",
                                         layer_name, "memory")
            attribute_object = final_layer.dataProvider()
            attribute_object.addAttributes([QgsField("name", QVariant.String),
                                            QgsField("Area", QVariant.Double)])
            final_layer.updateFields()

            # Adding features to the newly created layer
            for feature in layer_from_selected_feature.getFeatures():
                selected_feature_geometry = feature.geometry()

                feature_copy.setGeometry(selected_feature_geometry)
                feature_copy.setAttributes(["Main_plot", selected_feature_geometry.area() / 4046.86])

                attribute_object.addFeature(feature_copy)

            final_layer.updateExtents()

            selected_features_object = [new_feature for new_feature in final_layer.getFeatures()]

            if len(selected_features_object) == 0:
                print("select feature to subdivide")

            elif len(selected_features_object) == 1:

                # creating an empty road field in the attribute table
                feature_copy.setGeometry(QgsGeometry())
                feature_copy.setAttributes(["Road", 0])
                attribute_object.addFeature(feature_copy)
                final_layer.updateExtents()

                attribute_object.changeGeometryValues({2: clipped_road_geometry})
                self.selected_road_index = 2
                a = 2
                checker = True
                while checker:
                    # errors : area of 3 acres deletes the last feature. check size of area before deleting
                    # new_3 can only create 2 major subdivisions of 1 acre

                    feature_id_index = 1
                    feature_ids_list = [feature.id() for feature in final_layer.getFeatures()]
                    # print("Feature id list", feature_ids_list)
                    # print("initial feature id index = ", feature_id_index)
                    feature_counter_list = self.feature_creation_counter_list

                    # This is where you introduce the value of direction whether left or right
                    # print("Feature counter list ", feature_counter_list)
                    if len(feature_counter_list) > 0:
                        # feature_id_index = 1  # This is because road feature was added
                        final_feature_id = 4  # 4 because all second major subdivisions will be feature id 3 no
                        # matter the situation when starting subdivision from the left

                        if not self.no_subdivision:
                            if len(feature_counter_list) > 1:
                                new_features_count = feature_counter_list[-2]
                                deleted_major_subdivision_feature = 1
                                deleted_minor_subdivision_features = new_features_count - 1
                                if self.final_feature_id == self.repeat_feature_id:
                                    deleted_minor_subdivision_features = new_features_count
                                subdivided_major_subdivision = \
                                    self.final_feature_id + deleted_major_subdivision_feature + new_features_count + \
                                    deleted_minor_subdivision_features
                                final_feature_id = subdivided_major_subdivision

                            self.final_feature_id = final_feature_id
                            # print("feature id", self.final_feature_id)
                            feature_id_index = feature_id_index + feature_ids_list.index(self.final_feature_id)
                        else:
                            feature_id_index = feature_id_index + feature_ids_list.index(self.repeat_feature_id)
                            self.final_feature_id = self.repeat_feature_id

                    # print("major_subdivision_counter",  self.major_subdivision_counter)                    #
                    # print([feature.id() for feature in final_layer.getFeatures()])
                    # print("fet id ", feature_id)

                    # print("final feature id index = ", feature_id_index)

                    selected_feature_object = self.selected_feature(final_layer, feature_id_index)
                    # adding new feature to the created shapefile
                    total_parcel_area = self.area_of_parcel_in_acres(selected_feature_object)

                    # if self.major_subdivision_counter == 2:
                    #     feature_id = 2

                    # print("===", total_parcel_area / self.size_of_each_parcels)

                    if self.size_of_each_parcels == total_parcel_area:
                        print("Size of each parcel is equal to size of the parcel")
                        break

                    elif self.size_of_each_parcels < total_parcel_area:

                        # print("Major subdivision counter", self.major_subdivision_counter)
                        # print("Feature id", feature_id)

                        self.major_subdivision_1(feature_id_index,
                                                 final_layer,
                                                 attribute_object,
                                                 selected_feature_object)
                        # This adds a new feature to the existing
# This adds feader roads to parcels
                        self.create_new_road = a % 2 == 0
                        # print(a)
                        if not self.no_subdivision:
                            if False: # self.create_new_road:
                                road_feature = self.selected_feature(final_layer, 1)
                                vertex_1 = None
                                vertex_2 = None
                                if len(self.road_top_y_coord) > 0:
                                    road_top_y_coord = self.road_top_y_coord[-1]
                                    if self.exit_major_division_loop:
                                        if len(self.road_top_y_coord) > 2:
                                            road_top_y_coord = self.road_top_y_coord[-2]
                                    # print(road_top_y_coord)
                                    road_top_x_coord = self.vertex_1_to_create_road.x()
                                    vertex_1 = QgsPoint(road_top_x_coord, road_top_y_coord)
                                    vertex_2 = self.vertex_1_to_create_road
                                    for value in self.road_top_y_coord:
                                        self.road_top_y_coord.remove(value)
                                if self.exit_major_division_loop and len(self.road_top_y_coord) > 1:
                                    road_length = 0
                                elif self.minor_subdivision_counter > 1:
                                    road_length = length_of_line([vertex_1, vertex_2]) + self.road_width
                                else:
                                    road_length = length_of_line(self.list_of_shared_vertices) - 12.5

                                new_road_geometry, created_vertices = self.road_creator_constructor. \
                                    road_geometry_with_feeders(self.list_of_shared_vertices, road_length, road_feature)


                                # print(new_road_vertices)
                                # print(new_road_geometry)
                                # print(len(new_road_vertices))
                                feature_ids_list = [feature.id() for feature in final_layer.getFeatures()]
                                index_of_major_feature_in_list = feature_ids_list.index(self.other_feature_id)
                                major_feature = self.selected_feature(final_layer, index_of_major_feature_in_list + 1)
                                minor_feature = self.selected_feature(final_layer, index_of_major_feature_in_list + 1)
                                minor_vert = [vertex for vertex in minor_feature.geometry().vertices()]
                                # print(minor_vert)
                                major_feature_geometry = major_feature.geometry()
                                major_feature_vertices = [vertex for vertex in major_feature_geometry.vertices()]
                                major_feature_vertices = remove_duplicates_in_list(major_feature_vertices)
                                # initial_vertex_index = major_feature_vertices.index(self.vertex_1_to_create_road)
                                major_feature_vertices.remove(self.vertex_1_to_create_road)
                                created_vertices.reverse()
                                new_vertices = created_vertices + major_feature_vertices
                                new_vertices = convert_from_point_to_pointxy(new_vertices)
                                new_geometry = QgsGeometry.fromPolygonXY([new_vertices])
                                # for vertex in created_vertices:
                                #     major_feature_geometry.insertVertex(vertex.x(), vertex.y(), point_index)
                                # print(new_road_geometry)

                                attribute_object.changeGeometryValues({self.other_feature_id: new_geometry})
                                attribute_object.changeGeometryValues({2: new_road_geometry})
                                final_layer.updateFields()
                                final_layer.commitChanges()
                                #     # print(new_road_vertices, insert_index)
                                #     # print([vertex for vertex in road_geometry.vertices()])
                                #     # print(len([vertex for vertex in road_geometry.vertices()]))
                                # else:
                                self.create_new_road = False
                            #
                            a += 1
                        QgsProject.instance().addMapLayer(final_layer)

                        # if self.major_subdivision_counter == 3:
                        #     break

                        self.feature_creation_counter_list.append(self.minor_subdivision_counter)
                        # print(self.feature_creation_counter_list)
                        if self.exit_major_division_loop:
                            break
                    else:
                        print("Total parcel area is less than the area of subdivisions")
                        break
            else:
                print("select only one feature ")
        else:
            print("The parcel must be connected to a road network")


class ParcelDivider:
    """QGIS Plugin Implementation."""

    def __init__(self, interface):
        """Constructor.

        :param interface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type interface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.dlg = ParcelDividerDialog()
        # self.file_loc_btn_object = self.dlg.file_loc_button
        self.iface = interface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ParcelDivider_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&KeCADASTRE')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # variables from gui
        self.feature_object = None
        self.output_file_path = ""
        self.layer_names_list = None
        self.layer_object_list = None
        self.selected_layer = None
        self.layer_object = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ParcelDivider', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/parcel_subdivider/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'KeCADASTRE'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&KeCADASTRE'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_feature(self, sf_box_object, column_id_object, road_feature_object):
        sf_box_object.clear()
        road_feature_object.clear()
        selected_field = column_id_object.currentText()
        # layer_names = get_layer_names_and_objects()[0]
        feature_names_in_layer = [str(feature[selected_field]) for feature in self.layer_object.getFeatures()]
        # print(feature_names_in_layer)
        sf_box_object.addItems(feature_names_in_layer)
        road_feature_object.addItems(feature_names_in_layer)

    def select_column(self, layer_name_object, column_id_object, sf_box_object, road_feature_object,
                      selected_layer_name=None):
        column_id_object.clear()
        layer_names = get_layer_names_and_objects()[0]
        layer_objects = get_layer_names_and_objects()[1]
        if not selected_layer_name:
            selected_layer_name = layer_name_object.currentText()
        layer_index = 0
        try:
            layer_index = layer_names.index(selected_layer_name)
        except ValueError:
            layer_name_object.clear()
            layer_name_object.addItems(get_layer_names_and_objects()[0])
            print("layer removed")

        if len(layer_names) > 0:
            self.layer_object = layer_objects[layer_index]

            field_names_list = self.layer_object.fields().names()
            column_id_object.addItems(field_names_list)
            self.select_feature(sf_box_object, column_id_object, road_feature_object)
        else:
            sf_box_object.clear()
            road_feature_object.clear()
            print("Make sure you have loaded at least a layer")

    # TODO: Find a way that can avoid repeating the same functions the number of times the app is opened
    @staticmethod
    def output_path():
        print("try and see")

    def run(self):
        """Run method that performs all the real work"""

        # This method makes sure that GUI is set so a standard value after each execution
        def reset_gui():
            layer_name_object.clear()
            column_id_object.clear()
            sf_box_object.clear()
            parcel_no_object.setValue(0)
            parcel_size_object.setValue(0)
            road_width_object.clear()
            road_feature_object.clear()
            # area_units_object.clear()
            # distance_units_objects.clear()
            # position_box_object.clear()
            # direction_box_object.clear()
            # coordinate_box_object.clear()
            # output_edit_object.clear()

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        iface.mapCanvas().refresh()
        if self.first_start:
            self.first_start = False

        # gui objects
        layer_name_object = self.dlg.layer_box
        column_id_object = self.dlg.id_box
        sf_box_object = self.dlg.feature_box
        road_feature_object = self.dlg.road_feature_box_2
        parcel_no_object = self.dlg.parcel_no_box
        parcel_size_object = self.dlg.parcel_size_box
        road_width_object = self.dlg.road_box
        # output_edit_object = self.dlg.output_file_edit
        road_widths = ["9", "12", "15", "18", "20", "25", "30"]

        layer_name_object.activated[str].connect(lambda: self.select_column(layer_name_object, column_id_object,
                                                                            road_feature_object, sf_box_object))
        column_id_object.activated[str].connect(lambda: self.select_feature(sf_box_object,
                                                                            column_id_object, road_feature_object))

        selected_layer_object = layer_name_object.currentText()
        layer_names = get_layer_names_and_objects()[0]
        layer_name_object.addItems(layer_names)
        self.select_column(layer_name_object, column_id_object, sf_box_object, road_feature_object,
                           selected_layer_object)
        road_width_object.addItems(road_widths)
        # self.file_loc_btn_object.clicked.connect(lambda: output_edit_object.setText(QFileDialog.getSaveFileName()[0]))

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:

            # variables from GUI
            column_name = column_id_object.currentText()
            selected_layer_object = self.layer_object
            selected_feature_index = sf_box_object.currentIndex()
            selected_road_feature_index = road_feature_object.currentIndex()
            feature_object_list = [feature for feature in selected_layer_object.getFeatures()]
            selected_road_feature_id = feature_object_list[selected_road_feature_index].id()
            selected_feature_object = feature_object_list[selected_feature_index]
            selected_road_feature_name = road_feature_object.currentText()
            layer_name_object.addItems(get_layer_names_and_objects()[0])
            no_of_parcels = parcel_no_object.value()
            size_of_parcels = parcel_size_object.value()
            # area_unit_used = area_units_object.currentText()
            road_width = int(road_width_object.currentText())

            parcel_position = 0
            division_direction = 0
            area_unit_used = 0
            coordinate_system = 0
            length_unit_used = 0
            output_file_path = self.output_file_path
            #
            # no_of_parcels = 13
            # size_of_parcels = 2
            # selected_road_feature_id = 6
            selected_feature_object = feature_object_list[0]

            parcel_partitioner = SubdivisionCreator(size_of_parcels, no_of_parcels, road_width,
                                                    output_file_path, parcel_position, division_direction,
                                                    selected_layer_object, selected_feature_object, area_unit_used,
                                                    length_unit_used, coordinate_system, selected_road_feature_name,
                                                    column_name, selected_road_feature_id)
            parcel_partitioner.main()

            reset_gui()

        else:
            reset_gui()
